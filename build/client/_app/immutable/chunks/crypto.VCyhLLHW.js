var s={};s.byteLength=h;s.toByteArray=x;s.fromByteArray=g;var l=[],i=[],A=typeof Uint8Array<"u"?Uint8Array:Array,v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var p=0,f=v.length;p<f;++p)l[p]=v[p],i[v.charCodeAt(p)]=p;i[45]=62;i[95]=63;function u(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");r===-1&&(r=t);var n=r===t?0:4-r%4;return[r,n]}function h(e){var t=u(e),r=t[0],n=t[1];return(r+n)*3/4-n}function w(e,t,r){return(t+r)*3/4-r}function x(e){var t,r=u(e),n=r[0],c=r[1],a=new A(w(e,n,c)),o=0,d=c>0?n-4:n,y;for(y=0;y<d;y+=4)t=i[e.charCodeAt(y)]<<18|i[e.charCodeAt(y+1)]<<12|i[e.charCodeAt(y+2)]<<6|i[e.charCodeAt(y+3)],a[o++]=t>>16&255,a[o++]=t>>8&255,a[o++]=t&255;return c===2&&(t=i[e.charCodeAt(y)]<<2|i[e.charCodeAt(y+1)]>>4,a[o++]=t&255),c===1&&(t=i[e.charCodeAt(y)]<<10|i[e.charCodeAt(y+1)]<<4|i[e.charCodeAt(y+2)]>>2,a[o++]=t>>8&255,a[o++]=t&255),a}function F(e){return l[e>>18&63]+l[e>>12&63]+l[e>>6&63]+l[e&63]}function B(e,t,r){for(var n,c=[],a=t;a<r;a+=3)n=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(e[a+2]&255),c.push(F(n));return c.join("")}function g(e){for(var t,r=e.length,n=r%3,c=[],a=16383,o=0,d=r-n;o<d;o+=a)c.push(B(e,o,o+a>d?d:o+a));return n===1?(t=e[r-1],c.push(l[t>>2]+l[t<<4&63]+"==")):n===2&&(t=(e[r-2]<<8)+e[r-1],c.push(l[t>>10]+l[t>>4&63]+l[t<<2&63]+"=")),c.join("")}async function C(e,t=void 0){const r=new TextEncoder,n=crypto.getRandomValues(new Uint8Array(12)),c=s.fromByteArray(n),a={name:"AES-GCM",iv:n,length:256};let o;t?o=await crypto.subtle.importKey("raw",s.toByteArray(t),a,!1,["encrypt"]):(o=await crypto.subtle.generateKey(a,!0,["encrypt"]),t=s.fromByteArray(new Uint8Array(await crypto.subtle.exportKey("raw",o))));const d=await crypto.subtle.encrypt(a,o,r.encode(e));return{ciphertext:s.fromByteArray(new Uint8Array(d)),iv:c,key:t}}async function K(e,t,r){const n=new TextDecoder("utf-8"),a={name:"AES-GCM",iv:s.toByteArray(t),length:256},o=await crypto.subtle.importKey("raw",s.toByteArray(r),a,!1,["decrypt"]),d=await crypto.subtle.decrypt(a,o,s.toByteArray(e));return n.decode(d)}async function L(e,t){const r=new TextEncoder,n=crypto.getRandomValues(new Uint8Array(12)),c=s.fromByteArray(n),a={name:"AES-GCM",iv:n,length:256},o=await crypto.subtle.importKey("raw",r.encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]),d=await crypto.subtle.deriveKey({name:"PBKDF2",salt:await crypto.subtle.digest("SHA-512",r.encode(t)),iterations:31e4,hash:"SHA-512"},o,a,!1,["encrypt"]),y=await crypto.subtle.encrypt(a,d,r.encode(e));return{ciphertext:s.fromByteArray(new Uint8Array(y)),iv:c}}async function S(e,t,r){const n=new TextEncoder,c=new TextDecoder("utf-8"),a={name:"AES-GCM",iv:s.toByteArray(t),length:256},o=await crypto.subtle.importKey("raw",n.encode(r),"PBKDF2",!1,["deriveBits","deriveKey"]),d=await crypto.subtle.deriveKey({name:"PBKDF2",salt:await crypto.subtle.digest("SHA-512",n.encode(r)),iterations:31e4,hash:"SHA-512"},o,a,!1,["decrypt"]),y=await crypto.subtle.decrypt(a,d,s.toByteArray(e));return c.decode(y)}async function b(e,t){const n=new TextEncoder().encode(e+t),c=await crypto.subtle.digest("SHA-512",n);return s.fromByteArray(new Uint8Array(c))}export{K as decrypt,S as decryptWithPassword,C as encrypt,L as encryptWithPassword,b as hashPassword};
